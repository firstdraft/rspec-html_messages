# frozen_string_literal: true

require "zeitwerk"
require "active_support/backtrace_cleaner"

Zeitwerk::Loader.new.then do |loader|
  loader.tag = "rspec-html_messages"
  loader.push_dir "#{__dir__}/.."
  loader.setup
end

module Rspec
  # Main renderer class for converting enriched JSON examples to HTML
  module HtmlMessages
    include HtmlMessages::ValueFormatter
    include HtmlMessages::DiffFormatter
    include HtmlMessages::TemplateRenderer

    # Matchers that should always show diffs regardless of their diffable flag
    FORCE_DIFFABLE_MATCHERS = ["RSpec::Matchers::BuiltIn::ContainExactly"].freeze

    # Matchers that should never show diffs regardless of their diffable flag
    FORCE_NOT_DIFFABLE_MATCHERS = [
      "RSpec::Matchers::BuiltIn::Include",
      "RSpec::Matchers::BuiltIn::Compound::And",
      "RSpec::Matchers::BuiltIn::Compound::Or"
    ].freeze

    attr_reader :example

    def initialize(example)
      validate_example!(example)
      @example = example
    end

    def options
      @options ||= default_options
    end

    # Individual rendering methods - return nil when no content to display
    def output_html(**options)
      return nil unless has_output?

      @options = default_options.merge(options)
      @force_diffable = @options[:force_diffable]
      @force_not_diffable = @options[:force_not_diffable]

      if should_show_diff?
        render_template("_diff")
      else
        render_template("_actual")
      end
    end

    def failure_message_html(**options)
      @options = default_options.merge(options)

      # Don't show failure message for errors - that goes in exception details
      return nil unless has_failure_message?

      @failure_message_text = failure_message

      render_template("_failure_message")
    end

    def exception_details_html(**options)
      return nil unless has_exception_details?

      @options = default_options.merge(options)

      render_template("_exception_details")
    end

    def backtrace_html(**options)
      return nil unless has_backtrace?

      @options = default_options.merge(options)
      @backtrace_max_lines = @options[:backtrace_max_lines]
      @backtrace_silence_gems = @options[:backtrace_silence_gems]

      render_template("_backtrace")
    end

    def status_html(**options)
      if passed?
        css_class = "alert-success"
        message = "This test passed!"
      else
        css_class = "alert-warning"
        message = "The test did not pass."
      end
      render_template("_status", css_class: css_class, message: message)
    end

    # Public boolean methods so users can make their own decisions
    def has_output?
      # Don't show output for errors before assertions
      return false if error_before_assertion?

      failed? || has_actual?
    end

    def has_failure_message?
      failed? && !error_before_assertion? && failure_message.present?
    end

    def has_exception_details?
      error_before_assertion?
    end

    def has_backtrace?
      exception_backtrace.any?
    end

    # Example of how to use all three together
    def render_html(**options)
      @options = default_options.merge(options)
      render_template("example")
    end

    def self.diff_css
      # Minimal CSS for displaying diffs generated by Diffy
      <<~CSS
        .diff { overflow: auto; }
        .diff ul {
          overflow: auto;
          list-style: none;
          margin: 0;
          padding: 0;
          display: table;
          width: 100%;
        }
        .diff del, .diff ins {
          display: block;
          text-decoration: none;
        }
        .diff li {
          padding: 0;
          display: table-row;
          margin: 0;
          height: 1em;
        }
        .diff li.ins { background: #dfd; color: #080; }
        .diff li.del { background: #fee; color: #b00; }
        .diff li:hover { background: #ffc; }
        .diff del, .diff ins, .diff span { white-space: pre-wrap; }
        .diff del strong { font-weight: normal; background: #fcc; }
        .diff ins strong { font-weight: normal; background: #9f9; }
        .diff li.diff-comment { display: none; }
        .diff li.diff-block-info { background: none repeat scroll 0 0 gray; }
      CSS
    end

    private

    def passed?
      status == "passed"
    end

    def failed?
      status == "failed"
    end

    def default_options
      {
        force_diffable: FORCE_DIFFABLE_MATCHERS,
        force_not_diffable: FORCE_NOT_DIFFABLE_MATCHERS,
        rspec_diff_in_message: false,
        backtrace_max_lines: 10,
        backtrace_silence_gems: true
      }
    end

    def should_show_diff?
      show_diff?(force_diffable: @force_diffable, force_not_diffable: @force_not_diffable)
    end

    # Helper methods for templates
    def status
      example["status"]
    end

    def details
      @details ||= example["details"] || {}
    end

    def matcher_name
      details["matcher_name"] || "Unknown"
    end

    def failure_message
      @failure_message ||= calculate_failure_message
    end

    def calculate_failure_message
      return nil unless failed?

      message = example.dig("exception", "message")
      return nil unless message

      # Strip leading newline that RSpec's built-in matchers add
      message = message.sub(/\A\n/, "")

      # Strip RSpec's diff section if requested
      if !options[:rspec_diff_in_message]
        # RSpec appends diffs with "\nDiff:" or "\nDiff for (...):"
        # The diff always contains @@ markers (unified diff format) or the empty diff message
        # This regex requires either @@ or "The diff is empty" to appear after Diff:
        # to avoid false positives where "Diff:" might appear in user data
        message = message.sub(
          /\n\s*Diff(?:\s+for\s+\([^)]+\))?:.*?(?:@@|The diff is empty).*\z/m,
          ""
        )
      end

      message
    end

    def exception_class
      example.dig("exception", "class")
    end

    def exception_message
      example.dig("exception", "message")
    end

    def exception_backtrace
      example.dig("exception", "backtrace") || []
    end

    def has_exception?
      example.key?("exception")
    end

    def error_before_assertion?
      # Check if this is an error (not a matcher failure)
      has_exception? && !has_actual? && !has_expected?
    end

    def has_expected?
      details.key?("expected")
    end

    def backtrace_cleaner(silence_gems: true)
      ActiveSupport::BacktraceCleaner.new.tap do |bc|
        # Clean up paths by removing project root
        bc.add_filter { |line| line.gsub("#{project_root}/", "") }

        # Optionally silence gem frames
        if silence_gems
          bc.add_silencer { |line| line.include?("/gems/") && !line.include?(project_root) }
          bc.add_silencer { |line| line.include?("/bundle/") }
          bc.add_silencer { |line| line.match?(%r{/ruby/\d+\.\d+\.\d+/}) }
        end

        # Always silence RSpec internals
        bc.add_silencer { |line| line.match?(%r{/lib/rspec/(core|expectations|mocks)/}) }
      end
    end

    def project_root
      @project_root ||= File.expand_path("../..", File.dirname(example["file_path"]))
    end

    def has_actual?
      details.key?("actual")
    end

    def actual_value
      @actual_value ||= deserialize_value(details["actual"]) if has_actual?
    end

    def expected_value
      @expected_value ||= deserialize_value(details["expected"]) if has_expected?
    end

    def prettified_actual
      @prettified_actual ||= prettify_for_diff(actual_value)
    end

    def prettified_expected
      @prettified_expected ||= prettify_for_diff(expected_value)
    end

    def negated?
      details["negated"]
    end

    def show_diff?(force_diffable: [], force_not_diffable: [])
      return false if status == "passed"
      return false unless expected_value && actual_value
      return false if negated?

      # Check if values are identical (likely a negated matcher)
      return false if prettified_actual == prettified_expected

      effective_diffable?(force_diffable: force_diffable, force_not_diffable: force_not_diffable)
    end

    def diff_html
      @diff_html ||= create_diff(prettified_actual, prettified_expected)
    end

    def formatted_backtrace(max_lines: 10, silence_gems: true)
      return [] if exception_backtrace.empty?

      cleaned = backtrace_cleaner(silence_gems: silence_gems).clean(exception_backtrace)

      # If all lines were filtered out, show original with cleaned paths
      if cleaned.empty?
        cleaned = ActiveSupport::BacktraceCleaner.new.tap do |bc|
          bc.add_filter { |line| line.gsub("#{project_root}/", "") }
        end.clean(exception_backtrace)
      end

      cleaned.first(max_lines)
    end

    def friendly_error_location
      return nil if exception_backtrace.empty?

      first_line = exception_backtrace.first
      # Remove absolute path prefix to get relative path
      first_line = first_line.gsub(/^#{Regexp.escape(project_root)}\//, "")

      # Parse the backtrace line format: path:line:in 'method'
      if (match = first_line.match(/^(.+):(\d+):in ['`](.+)['`]$/))
        path, line_number, method = match.captures
        "#{exception_class} on line #{line_number} of #{path} in '#{method}'"
      else
        # Fallback to original format if parsing fails
        "#{exception_class}: #{first_line}"
      end
    end

    def validate_example!(example)
      raise ArgumentError, "Example cannot be nil" if example.nil?
      raise ArgumentError, "Example must be a Hash" unless example.is_a?(Hash)

      # Validate required fields
      required_fields = %w[id description status file_path line_number]
      missing_fields = required_fields - example.keys

      unless missing_fields.empty?
        raise ArgumentError, "Example is missing required fields: #{missing_fields.join(", ")}"
      end

      # Validate status value
      valid_statuses = %w[passed failed pending]
      unless valid_statuses.include?(example["status"])
        raise ArgumentError, "Invalid status: #{example["status"]}. Must be one of: #{valid_statuses.join(", ")}"
      end
    end
  end
end
